/*
Copyright (C) 2019, NVIDIA CORPORATION. All rights reserved.
Copyright (C) 2021 Frank Richter

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#version 460
#extension GL_GOOGLE_include_directive : enable

#include "path_tracer.h"
#include "utils.glsl"

layout(set = 0, binding = 4)
uniform utextureBuffer beam_info_buffer;

rt_hitAttribute HitAttributeBeam beam_hit_attrib;

// Adapted from: http://www.pbr-book.org/3ed-2018/Utilities/Mathematical_Routines.html#SolvingQuadraticEquations
bool solve_quadratic(in float a, in float b, in float c, out vec2 t)
{
	float discrim = b * b - 4 * a * c;
	if (discrim < 0) return false;
	float q;
	if (b < 0)
		q = -0.5 * (b - sqrt(discrim));
	else
		q = -0.5 * (b + sqrt(discrim));
	float t0 = q / a;
	float t1 = c / q;
	t = vec2(min(t0, t1), max(t0, t1));
	return true;
}

bool hit_cylinder(in vec3 o, in vec3 d, in float radius, out vec2 t)
{
	// Adapted from: http://www.pbr-book.org/3ed-2018/Shapes/Cylinders.html#IntersectionTests
	float a = dot(d.xy, d.xy);
	float b = 2 * dot(d.xy, o.xy);
	float c = dot(o.xy, o.xy) - radius * radius;

	return solve_quadratic(a, b, c, t);
}

bool hit_sphere(in vec3 o, in vec3 d, in float radius, out vec2 t)
{
	// Adapted from: http://www.pbr-book.org/3ed-2018/Shapes/Spheres.html#IntersectionTests
	float a = dot(d, d);
	float b = 2 * dot(d, o);
	float c = dot(o, o) - radius * radius;

	return solve_quadratic(a, b, c, t);
}

void main()
{
	const int beam_index = gl_PrimitiveID;
	const uvec4 beam_info[3] = { texelFetch(beam_info_buffer, beam_index * 3),
								 texelFetch(beam_info_buffer, beam_index * 3 + 1),
								 texelFetch(beam_info_buffer, beam_index * 3 + 2) };
	/* Transform from world space to "beam space" (really, object space),
	   where the beam starts at the origin and points towards +Z */
	const mat4 world_to_beam = mat4(unpackHalf4x16(beam_info[1].xy),
									unpackHalf4x16(beam_info[1].zw),
									unpackHalf4x16(beam_info[2].xy),
									uintBitsToFloat(beam_info[0]));
	const float beam_radius = uintBitsToFloat(beam_info[2].z);
	const float beam_length = uintBitsToFloat(beam_info[2].w);

	// Ray origin, direction in "beam space"
	const vec3 o = (world_to_beam * vec4(rt_WorldRayOrigin, 1)).xyz;
	const vec3 d = (world_to_beam * vec4(rt_WorldRayDirection, 0)).xyz;

	vec2 t;
	if(!hit_cylinder(o, d, beam_radius, t)) return;

	// The intersection Z values (ie "height on beam")
	vec2 hit_z = vec2(o.z) + vec2(d.z) * t;
	/* Check if we hit outside the cylinder bounds -
	   if so, see if we hit the "end spheres",
	   and update the hit location */
	bvec2 hit_below_0 = lessThan(hit_z, vec2(0));
	if(any(hit_below_0))
	{
		vec2 t_sphere;
		if(!hit_sphere(o, d, beam_radius, t_sphere)) return;
		if(hit_below_0.x) t.x = max(t.x, t_sphere.x);
		if(hit_below_0.y) t.y = min(t.y, t_sphere.y);
	}
	bvec2 hit_above_end = greaterThan(hit_z, vec2(beam_length));
	if(any(hit_above_end))
	{
		vec2 t_sphere;
		if(!hit_sphere(o - vec3(0, 0, beam_length), d, beam_radius, t_sphere)) return;
		if(hit_above_end.x) t.x = max(t.x, t_sphere.x);
		if(hit_above_end.y) t.y = min(t.y, t_sphere.y);
	}

	if((t.x >= rt_RayTmax) || (t.y < rt_RayTmin)) return;
	float tShapeHit = t.x;
	if (tShapeHit < rt_RayTmin)
	{
		tShapeHit = t.y;
		if (tShapeHit >= rt_RayTmax)
			return;
	}

	// Compute points on ray and beam center where they're closest to each other
	const vec3 perp_norm = normalize(vec3(d.y, -d.x, 0));
	const vec3 n2 = vec3(-perp_norm.y, perp_norm.x, 0);
	const float t1 = dot(-o, n2) / dot(d, n2);
	const vec3 n1 = cross(d, perp_norm);
	const float t2 = dot(o, n1) / n1.z;

	const vec3 c_ray = o + t1 * d; // Point on ray closest to beam center
	const vec3 c_beam = vec3(0, 0, t2); // Point on beam closest to ray

	/* Compute "distance" to beam center used for beam intensity.
	   Using the closest distance between the ray and the beam line segment
	   looks best when the beam is seen from the side;
	   Using the closest distance between the ray and the beam infinitely
	   extended looks looks best when looking at the beam "head on"
	   (ray parallel to beam) -
	   so mix between those two, based on the ray/beam angle.
	 */
	const float dist_side = distance(c_ray, vec3(0, 0, clamp(t2, 0, beam_length)));
	const float dist_head = distance(c_ray, c_beam);
	const float dist = mix(dist_side, dist_head, abs(d.z));

	float fade = 1.0 - dist / beam_radius;
	float thickness = t.y - t.x;
	fade *= clamp(thickness / (2 * beam_radius), 0, 1);
	beam_hit_attrib.fade_and_thickness = packHalf2x16(vec2(fade, thickness));

	rt_reportIntersection(tShapeHit, 0);
}
