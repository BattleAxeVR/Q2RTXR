/*
Copyright (C) 2019, NVIDIA CORPORATION. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#version 450
#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier    : enable

layout(constant_id = 0) const uint spec_input_tex = 0;

#include "utils.glsl"

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "global_ubo.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "global_textures.h"

#define A_GPU 1
#define A_GLSL 1
//#define A_HALF // TODO

#define FSR_RCAS_F 1

#include "ffx_a.h"
#include "ffx_fsr1.h"

layout(local_size_x=64) in;

AF4 FsrRcasLoadF(ASU2 p)
{
	if(spec_input_tex == 0)
		// RCAS after EASU
		return texelFetch(TEX_FSR_EASU_OUTPUT, ivec2(p), 0);
	else
		// RCAS after TAAU
		return texelFetch(TEX_TAA_OUTPUT, ivec2(p), 0);
}
void FsrRcasInputF(inout AF1 r, inout AF1 g, inout AF1 b) {}


void main()
{
	/* Code from EASU application has been lifted from:
	   https://raw.githubusercontent.com/GPUOpen-Effects/FidelityFX-FSR/master/docs/FidelityFX-FSR-Overview-Integration.pdf */

	// Do remapping of local xy in workgroup for a more PS-like swizzle pattern.
	AU2 gxy = ARmp8x8(gl_LocalInvocationID.x) + AU2(gl_WorkGroupID.x << 4u, gl_WorkGroupID.y << 4u);

	AF3 color;
	FsrRcasF(color.r, color.g, color.b, gxy, global_ubo.rcas_const0);
	imageStore(IMG_FSR_RCAS_OUTPUT, ivec2(gxy), vec4(color, 1));
	gxy.x += 8;

	FsrRcasF(color.r, color.g, color.b, gxy, global_ubo.rcas_const0);
	imageStore(IMG_FSR_RCAS_OUTPUT, ivec2(gxy), vec4(color, 1));
	gxy.y += 8;

	FsrRcasF(color.r, color.g, color.b, gxy, global_ubo.rcas_const0);
	imageStore(IMG_FSR_RCAS_OUTPUT, ivec2(gxy), vec4(color, 1));
	gxy.x -= 8;

	FsrRcasF(color.r, color.g, color.b, gxy, global_ubo.rcas_const0);
	imageStore(IMG_FSR_RCAS_OUTPUT, ivec2(gxy), vec4(color, 1));
}
